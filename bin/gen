#!/usr/bin/env perl

use v5.20;
use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path);
use File::Spec;
use Cwd qw(abs_path);
use Getopt::Long;

# Get project root directory (one level up from bin/)
my $script_dir = dirname(abs_path($0));
my $project_root = dirname($script_dir);

# Default environment variables
$ENV{CAPI_VERSION} ||= '3.195.0';
$ENV{OPENAPI_VERSION} ||= '3.1.1';

# Parse command line arguments
my $command;
my $capi_version;
my $language;
my $output_path;
my $generator;
my $help;

GetOptions(
    'version=s' => \$capi_version,
    'language=s' => \$language,
    'output=s' => \$output_path,
    'generator=s' => \$generator,
    'help' => \$help,
) or die usage();

# Get command from remaining args
$command = shift @ARGV || '';

# Show usage if help requested
if ($help) {
    print usage();
    exit(0);
}

# Handle different commands
if ($command eq 'prepare') {
    # Prepare command doesn't need version/language
    $capi_version //= $ENV{CAPI_VERSION};
    prepare($capi_version);
} elsif ($command eq 'merge') {
    # Merge OpenAPI spec command
    $capi_version //= $ENV{CAPI_VERSION};
    merge_openapi_spec($capi_version);
} elsif ($capi_version && $language) {
    # Generate SDK (original functionality)
    # Set default generator based on language
    if ($language eq 'go' && !$generator) {
        $generator = 'oapi-codegen';
    } else {
        $generator //= 'openapi-generator';
    }
    
    # Set default output path if not provided
    if ($language eq 'go') {
        # For Go, append the package name to the path
        $output_path //= File::Spec->catfile($project_root, 'sdk', $capi_version, $language, 'capiclient');
    } else {
        $output_path //= File::Spec->catfile($project_root, 'sdk', $capi_version, $language);
    }
    
    # Validate inputs
    validate_inputs();
    
    # Generate SDK
    generate_sdk();
} else {
    print usage();
    exit(1);
}

sub usage {
    return <<EOF;
Usage: $0 [COMMAND] [OPTIONS]

Commands:
  prepare [--version=VERSION]       Fetch specs and create CAPI files
  merge [--version=VERSION]         Merge YAML files into unified OpenAPI spec
  (no command)                      Generate SDK (requires --version and --language)

SDK Generation Options:
  --version=VERSION   CAPI version (e.g., 3.195.0)
  --language=LANGUAGE Target language for SDK generation
  
Optional options:
  --output=PATH       Output directory (default: ./sdk/VERSION/LANGUAGE/)
  --generator=GEN     Generator to use: openapi-generator, oapi-codegen
                      (default: oapi-codegen for Go, openapi-generator for others)
  --help              Show this help message

Supported languages:
  ada, android, apex, bash, c, clojure, cpp-qt-client, cpp-rest-sdk-client,
  cpp-tiny, cpp-ue4, cpp-pistache-server, cpp-restbed-server, crystal, csharp,
  csharp-netcore, dart, eiffel, elixir, elm, erlang-client, erlang-server, go,
  go-server, groovy, haskell-http-client, haskell, java, java-micronaut-client,
  java-micronaut-server, javascript, javascript-closure-angular, jaxrs-cxf-client,
  jaxrs-cxf, jaxrs-cxf-extended, jaxrs-jersey, jaxrs-resteasy, jaxrs-resteasy-eap,
  jaxrs-spec, kotlin, kotlin-server, kotlin-spring, lua, nim, objc, ocaml, perl,
  php, php-laravel, php-lumen, php-slim4, php-symfony, powershell, python,
  python-fastapi, python-flask, python-aiohttp, r, ruby, rust, rust-server,
  scala-akka, scala-akka-http-server, scala-finch, scala-gatling, scala-lagom-server,
  scala-play-server, scala-sttp, scalaz, spring, swift5, typescript-angular,
  typescript-aurelia, typescript-axios, typescript-fetch, typescript-inversify,
  typescript-jquery, typescript-nestjs, typescript-node, typescript-redux-query,
  typescript-rxjs

Examples:
  $0 prepare --version=3.195.0
  $0 merge --version=3.195.0
  $0 --version=3.195.0 --language=go                    # Uses oapi-codegen by default
  $0 --version=3.195.0 --language=go --generator=openapi-generator
  $0 --version=3.181.0 --language=python --output=/tmp/capi-python-sdk
EOF
}

sub validate_inputs {
    # Check if spec file exists
    my $spec_file = File::Spec->catfile($project_root, 'capi', "${capi_version}.openapi.json");
    unless (-f $spec_file) {
        die "Error: OpenAPI spec file not found: $spec_file\n" .
            "Please run './bin/gen merge --version=$capi_version' first to generate the specification.\n";
    }
    
    # Check if selected generator is available
    if ($generator eq 'oapi-codegen') {
        my $generator_check = `which oapi-codegen 2>/dev/null`;
        chomp $generator_check;
        unless ($generator_check) {
            die "Error: oapi-codegen not found.\n" .
                "Please install it with: go install github.com/deepmap/oapi-codegen/cmd/oapi-codegen\@latest\n";
        }
    } else {
        my $generator_check = `which openapi-generator 2>/dev/null || which openapi-generator-cli 2>/dev/null`;
        chomp $generator_check;
        unless ($generator_check) {
            die "Error: openapi-generator-cli not found.\n" .
                "Please run 'make deps' to install dependencies.\n";
        }
    }
}

sub generate_sdk {
    my $spec_file = File::Spec->catfile($project_root, 'capi', "${capi_version}.openapi.json");
    
    # Create output directory if it doesn't exist
    make_path($output_path) unless -d $output_path;
    
    my $cmd;
    my $result;
    
    if ($generator eq 'oapi-codegen') {
        # Use oapi-codegen for Go
        if ($language ne 'go') {
            die "Error: oapi-codegen only supports Go language generation.\n";
        }
        
        # Build output file path
        my $output_file = File::Spec->catfile($output_path, 'client.go');
        
        # Build the command
        $cmd = "oapi-codegen -generate types,client -package capiclient '$spec_file' > '$output_file'";
        
        # Execute the command
        say "Generating $language SDK for CAPI $capi_version using oapi-codegen...";
        say "Command: $cmd";
        
        $result = system($cmd);
        
        # Generate go.mod file if successful
        if ($result == 0) {
            generate_go_mod($output_path, $capi_version);
        }
    } else {
        # Use openapi-generator
        # Determine which command to use (openapi-generator or openapi-generator-cli)
        my $generator_cmd = `which openapi-generator 2>/dev/null`;
        chomp $generator_cmd;
        $generator_cmd = 'openapi-generator-cli' unless $generator_cmd;
        
        # Build the command
        $cmd = "$generator_cmd generate " .
                  "-i '$spec_file' " .
                  "-g '$language' " .
                  "-o '$output_path' " .
                  "--skip-validate-spec";
        
        # Add config file if it exists for Go
        my $config_file = File::Spec->catfile($project_root, 'openapi-generator-config.yml');
        if ($language eq 'go' && -f $config_file) {
            $cmd .= " -c '$config_file'";
        }
        
        # Add GitHub configuration
        my $github_org = 'cloudfoundry-community';
        my $github_repo = "capi-openapi-${language}-client";
        $cmd .= " --git-user-id='$github_org' --git-repo-id='$github_repo'";
        
        # Add language-specific options
        my $additional_props = get_additional_properties($language);
        $cmd .= " --additional-properties='$additional_props'" if $additional_props;
        
        # Execute the command
        say "Generating $language SDK for CAPI $capi_version using openapi-generator...";
        say "Command: $cmd";
        
        $result = system($cmd);
    }
    
    if ($result == 0) {
        say "\nSDK generated successfully!";
        say "Output directory: $output_path";
        if ($generator eq 'oapi-codegen') {
            say "Generated file: " . File::Spec->catfile($output_path, 'client.go');
        }
    } else {
        die "\nError: Failed to generate SDK. Exit code: " . ($result >> 8) . "\n";
    }
}

sub get_additional_properties {
    my ($lang) = @_;
    
    # Language-specific additional properties
    my %lang_props = (
        'go' => 'packageName=capiclient,generateInterfaces=true',
        'python' => 'packageName=capi_client,projectName=capi-client',
        'java' => 'groupId=org.cloudfoundry,artifactId=capi-client,artifactVersion=' . $capi_version,
        'javascript' => 'npmName=\@cloudfoundry/capi-client,npmVersion=' . $capi_version,
        'typescript-node' => 'npmName=\@cloudfoundry/capi-client,npmVersion=' . $capi_version,
        'ruby' => 'gemName=capi_client,gemVersion=' . $capi_version,
        'php' => 'packageName=CloudFoundry\\\\CAPI,composerPackageName=cloudfoundry/capi-client',
        'csharp' => 'packageName=CloudFoundry.CAPI,packageVersion=' . $capi_version,
        'rust' => 'packageName=capi_client,packageVersion=' . $capi_version,
    );
    
    return $lang_props{$lang} // '';
}

sub generate_go_mod {
    my ($output_dir, $version) = @_;
    
    my $go_mod_path = File::Spec->catfile($output_dir, 'go.mod');
    
    # Extract major version from version string (e.g., 3.195.0 -> v3)
    my $major_version = '';
    if ($version =~ /^(\d+)\./) {
        $major_version = "/v$1" if $1 >= 2;  # Go modules use /v2, /v3, etc for v2+
    }
    
    my $go_mod_content = <<EOF;
module github.com/cloudfoundry-community/capi-openapi-go-client/capiclient${major_version}

go 1.21

require (
\tgithub.com/oapi-codegen/runtime v1.1.1
\tgopkg.in/yaml.v2 v2.4.0
)

require (
\tgithub.com/apapsch/go-jsonmerge/v2 v2.0.0 // indirect
\tgithub.com/google/uuid v1.5.0 // indirect
)
EOF
    
    say "Creating go.mod file...";
    open(my $fh, '>', $go_mod_path) or die "Cannot create go.mod: $!";
    print $fh $go_mod_content;
    close($fh);
    
    # Run go mod tidy to ensure dependencies are correct
    my $original_dir = `pwd`;
    chomp $original_dir;
    chdir($output_dir);
    
    say "Running go mod tidy...";
    my $tidy_result = system("go mod tidy");
    
    chdir($original_dir);
    
    if ($tidy_result == 0) {
        say "go.mod created successfully!";
    } else {
        say "Warning: go mod tidy failed. You may need to run it manually.";
    }
}

sub check_deps {
    my @deps = qw(spruce jq);
    for my $dep (@deps) {
        my $cmd = "which $dep";
        my $result = `$cmd`;
        if ($result eq '') {
            print "Dependency '$dep' not found. Please install it.\n";
            exit 1;
        }
    }
}

sub fetch_spec {
    my ($spec_name, $spec_version, $spec_url) = @_;
    my $specs_path = "${project_root}/specs";
    my $spec_file = "${specs_path}/${spec_name}/${spec_version}.html";

    if (-e $spec_file) {
        print "Spec file '${spec_file}' already downloaded.\n";
        return
    } else {
        print "Fetching spec from '${spec_url}' to '${spec_file}'\n";
        make_path(dirname($spec_file)) unless -d dirname($spec_file);
        my $cmd = "curl -sL '${spec_url}' -o '${spec_file}'";
        printf("Running command: '%s'\n", $cmd);
        system($cmd);
        if ($? == -1) {
            print "Failed to execute: $!\n";
        }
    }
}

sub create_capi_files {
    my ($version) = @_;
    my @endpoints = qw(
        capi admin app_usage_events apps audit_events auth buildpacks builds
        deployments domains droplets environment_variable_groups errors
        feature_flags info isolation_segments jobs organization_quotas
        organizations packages processes resource_matches revisions roles
        root routes security_groups service_brokers service_credential_bindings
        service_instances service_offerings service_plan_visibility
        service_plans service_route_bindings service_usage_events sidecars
        space_quotas spaces stacks tasks users
    );
    
    my $capi_dir = "${project_root}/capi/${version}";
    make_path($capi_dir) unless -d $capi_dir;
    
    for my $endpoint (@endpoints) {
        my $endpoint_file = "${capi_dir}/${endpoint}.yml";
        `touch ${endpoint_file}` unless -e $endpoint_file;
    }
}

sub prepare {
    my ($version) = @_;
    print "Preparing CAPI specifications for version $version...\n";
    
    my $specs = {
        'capi' => {
            version => $version,
            url => "https://v3-apidocs.cloudfoundry.org/version/${version}/index.html",
        },
        'openapi' => {
            version => $ENV{OPENAPI_VERSION},
            url => "https://spec.openapis.org/oas/$ENV{OPENAPI_VERSION}.html",
        },
    };
    
    for my $spec (keys %$specs) {
        fetch_spec($spec, $specs->{$spec}->{version}, $specs->{$spec}->{url});
    }
    create_capi_files($version);
    print "Preparation complete!\n";
}

sub merge_openapi_spec {
    my ($version) = @_;
    print "Merging CAPI OpenAPI specifications for version $version...\n";
    
    check_deps();
    
    my @endpoints = qw(
        capi admin app_usage_events apps audit_events auth buildpacks builds
        deployments domains droplets environment_variable_groups errors
        feature_flags info isolation_segments jobs organization_quotas
        organizations packages processes resource_matches revisions roles
        root routes security_groups service_brokers service_credential_bindings
        service_instances service_offerings service_plan_visibility
        service_plans service_route_bindings service_usage_events sidecars
        space_quotas spaces stacks tasks users
    );

    my @yamls = ();
    for my $endpoint (@endpoints) {
        my $endpoint_file = "${project_root}/capi/${version}/${endpoint}.yml";
        push @yamls, $endpoint_file;
    }

    my $capi_openapi_prefix = "${project_root}/capi/${version}.openapi";
    my $cmd = "spruce merge -m '" . join("' '", @yamls) . "' > ${capi_openapi_prefix}.yml";
    printf("Running command: '%s'\n", $cmd);
    system($cmd);
    if ($? == -1) {
        print "Failed to execute: $!\n";
        exit 1;
    }
    
    $cmd = "spruce json ${capi_openapi_prefix}.yml | jq > ${capi_openapi_prefix}.json";
    printf("Running command: '%s'\n", $cmd);
    system($cmd);
    if ($? == -1) {
        print "Failed to execute: $!\n";
        exit 1;
    }
    
    print "OpenAPI spec merged successfully!\n";
    print "Generated: ${capi_openapi_prefix}.yml\n";
    print "Generated: ${capi_openapi_prefix}.json\n";
}