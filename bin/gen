#!/usr/bin/env perl

use v5.20;
use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path);
use File::Spec;
use Cwd qw(abs_path);
use Getopt::Long;

# Get project root directory (one level up from bin/)
my $script_dir = dirname(abs_path($0));
my $project_root = dirname($script_dir);

# Default environment variables
$ENV{CAPI_VERSION} ||= '3.195.0';
$ENV{OPENAPI_VERSION} ||= '3.1.1';

# Parse command line arguments
my $command;
my $capi_version;
my $language;
my $output_path;
my $help;

GetOptions(
    'version=s' => \$capi_version,
    'language=s' => \$language,
    'output=s' => \$output_path,
    'help' => \$help,
) or die usage();

# Get command from remaining args
$command = shift @ARGV || '';

# Show usage if help requested
if ($help) {
    print usage();
    exit(0);
}

# Handle different commands
if ($command eq 'prepare') {
    # Prepare command doesn't need version/language
    $capi_version //= $ENV{CAPI_VERSION};
    prepare($capi_version);
} elsif ($command eq 'merge') {
    # Merge OpenAPI spec command
    $capi_version //= $ENV{CAPI_VERSION};
    merge_openapi_spec($capi_version);
} elsif ($capi_version && $language) {
    # Generate SDK (original functionality)
    # Set default output path if not provided
    $output_path //= File::Spec->catfile($project_root, 'sdk', $capi_version, $language);
    
    # Validate inputs
    validate_inputs();
    
    # Generate SDK
    generate_sdk();
} else {
    print usage();
    exit(1);
}

sub usage {
    return <<EOF;
Usage: $0 [COMMAND] [OPTIONS]

Commands:
  prepare [--version=VERSION]       Fetch specs and create CAPI files
  merge [--version=VERSION]         Merge YAML files into unified OpenAPI spec
  (no command)                      Generate SDK (requires --version and --language)

SDK Generation Options:
  --version=VERSION   CAPI version (e.g., 3.195.0)
  --language=LANGUAGE Target language for SDK generation
  
Optional options:
  --output=PATH       Output directory (default: ./sdk/VERSION/LANGUAGE/)
  --help              Show this help message

Supported languages:
  ada, android, apex, bash, c, clojure, cpp-qt-client, cpp-rest-sdk-client,
  cpp-tiny, cpp-ue4, cpp-pistache-server, cpp-restbed-server, crystal, csharp,
  csharp-netcore, dart, eiffel, elixir, elm, erlang-client, erlang-server, go,
  go-server, groovy, haskell-http-client, haskell, java, java-micronaut-client,
  java-micronaut-server, javascript, javascript-closure-angular, jaxrs-cxf-client,
  jaxrs-cxf, jaxrs-cxf-extended, jaxrs-jersey, jaxrs-resteasy, jaxrs-resteasy-eap,
  jaxrs-spec, kotlin, kotlin-server, kotlin-spring, lua, nim, objc, ocaml, perl,
  php, php-laravel, php-lumen, php-slim4, php-symfony, powershell, python,
  python-fastapi, python-flask, python-aiohttp, r, ruby, rust, rust-server,
  scala-akka, scala-akka-http-server, scala-finch, scala-gatling, scala-lagom-server,
  scala-play-server, scala-sttp, scalaz, spring, swift5, typescript-angular,
  typescript-aurelia, typescript-axios, typescript-fetch, typescript-inversify,
  typescript-jquery, typescript-nestjs, typescript-node, typescript-redux-query,
  typescript-rxjs

Examples:
  $0 prepare --version=3.195.0
  $0 merge --version=3.195.0
  $0 --version=3.195.0 --language=go
  $0 --version=3.181.0 --language=python --output=/tmp/capi-python-sdk
EOF
}

sub validate_inputs {
    # Check if spec file exists
    my $spec_file = File::Spec->catfile($project_root, 'capi', "${capi_version}.openapi.json");
    unless (-f $spec_file) {
        die "Error: OpenAPI spec file not found: $spec_file\n" .
            "Please run './bin/gen merge --version=$capi_version' first to generate the specification.\n";
    }
    
    # Check if openapi-generator is available
    my $generator_check = `which openapi-generator 2>/dev/null || which openapi-generator-cli 2>/dev/null`;
    chomp $generator_check;
    unless ($generator_check) {
        die "Error: openapi-generator-cli not found.\n" .
            "Please run 'make deps' to install dependencies.\n";
    }
}

sub generate_sdk {
    my $spec_file = File::Spec->catfile($project_root, 'capi', "${capi_version}.openapi.json");
    
    # Create output directory if it doesn't exist
    make_path($output_path) unless -d $output_path;
    
    # Determine which command to use (openapi-generator or openapi-generator-cli)
    my $generator_cmd = `which openapi-generator 2>/dev/null`;
    chomp $generator_cmd;
    $generator_cmd = 'openapi-generator-cli' unless $generator_cmd;
    
    # Build the command
    my $cmd = "$generator_cmd generate " .
              "-i '$spec_file' " .
              "-g '$language' " .
              "-o '$output_path' " .
              "--skip-validate-spec";
    
    # Add language-specific options
    my $additional_props = get_additional_properties($language);
    $cmd .= " --additional-properties='$additional_props'" if $additional_props;
    
    # Execute the command
    say "Generating $language SDK for CAPI $capi_version...";
    say "Command: $cmd";
    
    my $result = system($cmd);
    
    if ($result == 0) {
        say "\nSDK generated successfully!";
        say "Output directory: $output_path";
    } else {
        die "\nError: Failed to generate SDK. Exit code: " . ($result >> 8) . "\n";
    }
}

sub get_additional_properties {
    my ($lang) = @_;
    
    # Language-specific additional properties
    my %lang_props = (
        'go' => 'packageName=capiclient,isGoSubmodule=true,generateInterfaces=true',
        'python' => 'packageName=capi_client,projectName=capi-client',
        'java' => 'groupId=org.cloudfoundry,artifactId=capi-client,artifactVersion=' . $capi_version,
        'javascript' => 'npmName=@cloudfoundry/capi-client,npmVersion=' . $capi_version,
        'typescript-node' => 'npmName=@cloudfoundry/capi-client,npmVersion=' . $capi_version,
        'ruby' => 'gemName=capi_client,gemVersion=' . $capi_version,
        'php' => 'packageName=CloudFoundry\\\\CAPI,composerPackageName=cloudfoundry/capi-client',
        'csharp' => 'packageName=CloudFoundry.CAPI,packageVersion=' . $capi_version,
        'rust' => 'packageName=capi_client,packageVersion=' . $capi_version,
    );
    
    return $lang_props{$lang} // '';
}

sub check_deps {
    my @deps = qw(spruce jq);
    for my $dep (@deps) {
        my $cmd = "which $dep";
        my $result = `$cmd`;
        if ($result eq '') {
            print "Dependency '$dep' not found. Please install it.\n";
            exit 1;
        }
    }
}

sub fetch_spec {
    my ($spec_name, $spec_version, $spec_url) = @_;
    my $specs_path = "${project_root}/specs";
    my $spec_file = "${specs_path}/${spec_name}/${spec_version}.html";

    if (-e $spec_file) {
        print "Spec file '${spec_file}' already downloaded.\n";
        return
    } else {
        print "Fetching spec from '${spec_url}' to '${spec_file}'\n";
        make_path(dirname($spec_file)) unless -d dirname($spec_file);
        my $cmd = "curl -sL '${spec_url}' -o '${spec_file}'";
        printf("Running command: '%s'\n", $cmd);
        system($cmd);
        if ($? == -1) {
            print "Failed to execute: $!\n";
        }
    }
}

sub create_capi_files {
    my ($version) = @_;
    my @endpoints = qw(
        capi admin app_usage_events apps audit_events auth buildpacks builds
        deployments domains droplets environment_variable_groups errors
        feature_flags info isolation_segments jobs organization_quotas
        organizations packages processes resource_matches revisions roles
        root routes security_groups service_brokers service_credential_bindings
        service_instances service_offerings service_plan_visibility
        service_plans service_route_bindings service_usage_events sidecars
        space_quotas spaces stacks tasks users
    );
    
    my $capi_dir = "${project_root}/capi/${version}";
    make_path($capi_dir) unless -d $capi_dir;
    
    for my $endpoint (@endpoints) {
        my $endpoint_file = "${capi_dir}/${endpoint}.yml";
        `touch ${endpoint_file}` unless -e $endpoint_file;
    }
}

sub prepare {
    my ($version) = @_;
    print "Preparing CAPI specifications for version $version...\n";
    
    my $specs = {
        'capi' => {
            version => $version,
            url => "https://v3-apidocs.cloudfoundry.org/version/${version}/index.html",
        },
        'openapi' => {
            version => $ENV{OPENAPI_VERSION},
            url => "https://spec.openapis.org/oas/$ENV{OPENAPI_VERSION}.html",
        },
    };
    
    for my $spec (keys %$specs) {
        fetch_spec($spec, $specs->{$spec}->{version}, $specs->{$spec}->{url});
    }
    create_capi_files($version);
    print "Preparation complete!\n";
}

sub merge_openapi_spec {
    my ($version) = @_;
    print "Merging CAPI OpenAPI specifications for version $version...\n";
    
    check_deps();
    
    my @endpoints = qw(
        capi admin app_usage_events apps audit_events auth buildpacks builds
        deployments domains droplets environment_variable_groups errors
        feature_flags info isolation_segments jobs organization_quotas
        organizations packages processes resource_matches revisions roles
        root routes security_groups service_brokers service_credential_bindings
        service_instances service_offerings service_plan_visibility
        service_plans service_route_bindings service_usage_events sidecars
        space_quotas spaces stacks tasks users
    );

    my @yamls = ();
    for my $endpoint (@endpoints) {
        my $endpoint_file = "${project_root}/capi/${version}/${endpoint}.yml";
        push @yamls, $endpoint_file;
    }

    my $capi_openapi_prefix = "${project_root}/capi/${version}.openapi";
    my $cmd = "spruce merge -m '" . join("' '", @yamls) . "' > ${capi_openapi_prefix}.yml";
    printf("Running command: '%s'\n", $cmd);
    system($cmd);
    if ($? == -1) {
        print "Failed to execute: $!\n";
        exit 1;
    }
    
    $cmd = "spruce json ${capi_openapi_prefix}.yml | jq > ${capi_openapi_prefix}.json";
    printf("Running command: '%s'\n", $cmd);
    system($cmd);
    if ($? == -1) {
        print "Failed to execute: $!\n";
        exit 1;
    }
    
    print "OpenAPI spec merged successfully!\n";
    print "Generated: ${capi_openapi_prefix}.yml\n";
    print "Generated: ${capi_openapi_prefix}.json\n";
}